<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SmartSoft Component-Developer API: Smart::IEventClientPattern&lt; ActivationType, EventType, EventIdType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartSoft Component-Developer API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="http://www.servicerobotik-ulm.de"><span>servicerobotik-ulm.de</span></a></li>
      <li><a href="index.html"><span>Introduction</span></a></li>
      <li><a href="namespaceSmart.html"><span>API&#160;Index</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSmart.html">Smart</a></li><li class="navelem"><a class="el" href="classSmart_1_1IEventClientPattern.html">IEventClientPattern</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSmart_1_1IEventClientPattern-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Smart::IEventClientPattern&lt; ActivationType, EventType, EventIdType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Handles the event service on client side.  
 <a href="classSmart_1_1IEventClientPattern.html#details">More...</a></p>

<p><code>#include &lt;smartIEventClientPattern_T.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Smart::IEventClientPattern&lt; ActivationType, EventType, EventIdType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSmart_1_1IEventClientPattern.png" usemap="#Smart::IEventClientPattern_3C_20ActivationType_2C_20EventType_2C_20EventIdType_20_3E_map" alt=""/>
  <map id="Smart::IEventClientPattern_3C_20ActivationType_2C_20EventType_2C_20EventIdType_20_3E_map" name="Smart::IEventClientPattern&lt; ActivationType, EventType, EventIdType &gt;_map">
<area href="classSmart_1_1IClientPattern.html" title="This is the base class for all client-patterns implementing a connection-oriented communication..." alt="Smart::IClientPattern" shape="rect" coords="0,112,413,136"/>
<area href="classSmart_1_1InputSubject.html" alt="Smart::InputSubject&lt; EventInputType&lt; EventType, EventIdType &gt; &gt;" shape="rect" coords="423,112,836,136"/>
<area href="classSmart_1_1ICommunicationPattern.html" title="This is the base class for all communication-patterns. " alt="Smart::ICommunicationPattern" shape="rect" coords="0,56,413,80"/>
<area href="classSmart_1_1IShutdownObserver.html" title="This class implements the Observer part of the Observer design pattern for implementing a uniform shu..." alt="Smart::IShutdownObserver" shape="rect" coords="0,0,413,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa31275b23b784378e87304f90c2f6557"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IEventClientPattern.html#aa31275b23b784378e87304f90c2f6557">IEventClientPattern</a> (<a class="el" href="classSmart_1_1IComponent.html">IComponent</a> *component)</td></tr>
<tr class="memdesc:aa31275b23b784378e87304f90c2f6557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (not wired with a service provider).  <a href="#aa31275b23b784378e87304f90c2f6557">More...</a><br /></td></tr>
<tr class="separator:aa31275b23b784378e87304f90c2f6557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc246ea05d3c8621d575e7c2e4fcb888"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IEventClientPattern.html#acc246ea05d3c8621d575e7c2e4fcb888">IEventClientPattern</a> (<a class="el" href="classSmart_1_1IComponent.html">IComponent</a> *component, const std::string &amp;server, const std::string &amp;service)</td></tr>
<tr class="memdesc:acc246ea05d3c8621d575e7c2e4fcb888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection Constructor (implicitly wiring with specified service provider).  <a href="#acc246ea05d3c8621d575e7c2e4fcb888">More...</a><br /></td></tr>
<tr class="separator:acc246ea05d3c8621d575e7c2e4fcb888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7b30e7b67ec066f79d87570446a546"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IEventClientPattern.html#aad7b30e7b67ec066f79d87570446a546">~IEventClientPattern</a> ()</td></tr>
<tr class="memdesc:aad7b30e7b67ec066f79d87570446a546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aad7b30e7b67ec066f79d87570446a546">More...</a><br /></td></tr>
<tr class="separator:aad7b30e7b67ec066f79d87570446a546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d1a4d93b3bd3fdd35cd1170ab8af77"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IEventClientPattern.html#a54d1a4d93b3bd3fdd35cd1170ab8af77">activate</a> (const <a class="el" href="namespaceSmart.html#ae5bad991dc9ede71fd0a70b79256e5b4">EventMode</a> &amp;mode, const ActivationType &amp;parameter, EventIdType &amp;id)=0</td></tr>
<tr class="memdesc:a54d1a4d93b3bd3fdd35cd1170ab8af77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate an event with the provided parameters in either "single" or "continuous" mode.  <a href="#a54d1a4d93b3bd3fdd35cd1170ab8af77">More...</a><br /></td></tr>
<tr class="separator:a54d1a4d93b3bd3fdd35cd1170ab8af77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2531c5fe345b438cf721acf902509f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IEventClientPattern.html#ad2531c5fe345b438cf721acf902509f2">deactivate</a> (const EventIdType &amp;id)=0</td></tr>
<tr class="memdesc:ad2531c5fe345b438cf721acf902509f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate the event with the specified identifier.  <a href="#ad2531c5fe345b438cf721acf902509f2">More...</a><br /></td></tr>
<tr class="separator:ad2531c5fe345b438cf721acf902509f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6f5f3a58ca6cde39da1bb35eef059f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IEventClientPattern.html#afe6f5f3a58ca6cde39da1bb35eef059f">tryEvent</a> (const EventIdType &amp;id)=0</td></tr>
<tr class="memdesc:afe6f5f3a58ca6cde39da1bb35eef059f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether event has already fired and return immediately with status information.  <a href="#afe6f5f3a58ca6cde39da1bb35eef059f">More...</a><br /></td></tr>
<tr class="separator:afe6f5f3a58ca6cde39da1bb35eef059f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472aa91ad4afd8e5d17ba6007e96e13f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IEventClientPattern.html#a472aa91ad4afd8e5d17ba6007e96e13f">getEvent</a> (const EventIdType &amp;id, EventType &amp;event, const std::chrono::steady_clock::duration &amp;timeout=std::chrono::steady_clock::duration::zero())=0</td></tr>
<tr class="memdesc:a472aa91ad4afd8e5d17ba6007e96e13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking call which waits for the event to fire and then consumes the event.  <a href="#a472aa91ad4afd8e5d17ba6007e96e13f">More...</a><br /></td></tr>
<tr class="separator:a472aa91ad4afd8e5d17ba6007e96e13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0912acfa105b45df68c8ee8c001c5f6e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IEventClientPattern.html#a0912acfa105b45df68c8ee8c001c5f6e">getNextEvent</a> (const EventIdType &amp;id, EventType &amp;event, const std::chrono::steady_clock::duration &amp;timeout=std::chrono::steady_clock::duration::zero())=0</td></tr>
<tr class="memdesc:a0912acfa105b45df68c8ee8c001c5f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking call which waits for the next event.  <a href="#a0912acfa105b45df68c8ee8c001c5f6e">More...</a><br /></td></tr>
<tr class="separator:a0912acfa105b45df68c8ee8c001c5f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSmart_1_1IClientPattern"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSmart_1_1IClientPattern')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSmart_1_1IClientPattern.html">Smart::IClientPattern</a></td></tr>
<tr class="memitem:ae66f7b99bccf4c0eaa8cc0155b486e2f inherit pub_methods_classSmart_1_1IClientPattern"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IClientPattern.html#ae66f7b99bccf4c0eaa8cc0155b486e2f">IClientPattern</a> (<a class="el" href="classSmart_1_1IComponent.html">IComponent</a> *component)</td></tr>
<tr class="memdesc:ae66f7b99bccf4c0eaa8cc0155b486e2f inherit pub_methods_classSmart_1_1IClientPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor (not yet connecting with any service provider).  <a href="#ae66f7b99bccf4c0eaa8cc0155b486e2f">More...</a><br /></td></tr>
<tr class="separator:ae66f7b99bccf4c0eaa8cc0155b486e2f inherit pub_methods_classSmart_1_1IClientPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f2a52bb4e7f1f15f05437b9e18e9c0 inherit pub_methods_classSmart_1_1IClientPattern"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IClientPattern.html#a18f2a52bb4e7f1f15f05437b9e18e9c0">IClientPattern</a> (<a class="el" href="classSmart_1_1IComponent.html">IComponent</a> *component, const std::string &amp;server, const std::string &amp;service)</td></tr>
<tr class="memdesc:a18f2a52bb4e7f1f15f05437b9e18e9c0 inherit pub_methods_classSmart_1_1IClientPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection Constructor (implicitly connecting with specified service provider).  <a href="#a18f2a52bb4e7f1f15f05437b9e18e9c0">More...</a><br /></td></tr>
<tr class="separator:a18f2a52bb4e7f1f15f05437b9e18e9c0 inherit pub_methods_classSmart_1_1IClientPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c1d227148aa061a036402de14291e1 inherit pub_methods_classSmart_1_1IClientPattern"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IClientPattern.html#a36c1d227148aa061a036402de14291e1">~IClientPattern</a> ()</td></tr>
<tr class="memdesc:a36c1d227148aa061a036402de14291e1 inherit pub_methods_classSmart_1_1IClientPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#a36c1d227148aa061a036402de14291e1">More...</a><br /></td></tr>
<tr class="separator:a36c1d227148aa061a036402de14291e1 inherit pub_methods_classSmart_1_1IClientPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808efd9034aa40430d793de89afc0e76 inherit pub_methods_classSmart_1_1IClientPattern"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IClientPattern.html#a808efd9034aa40430d793de89afc0e76">connect</a> (const std::string &amp;server, const std::string &amp;service)=0</td></tr>
<tr class="memdesc:a808efd9034aa40430d793de89afc0e76 inherit pub_methods_classSmart_1_1IClientPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect this service requestor to the denoted service provider.  <a href="#a808efd9034aa40430d793de89afc0e76">More...</a><br /></td></tr>
<tr class="separator:a808efd9034aa40430d793de89afc0e76 inherit pub_methods_classSmart_1_1IClientPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f945d0007606b60d1c17327cc56627e inherit pub_methods_classSmart_1_1IClientPattern"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IClientPattern.html#a7f945d0007606b60d1c17327cc56627e">disconnect</a> ()=0</td></tr>
<tr class="memdesc:a7f945d0007606b60d1c17327cc56627e inherit pub_methods_classSmart_1_1IClientPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the service requestor from the service provider.  <a href="#a7f945d0007606b60d1c17327cc56627e">More...</a><br /></td></tr>
<tr class="separator:a7f945d0007606b60d1c17327cc56627e inherit pub_methods_classSmart_1_1IClientPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67a2757eb3087a2a35fa538e702fc66 inherit pub_methods_classSmart_1_1IClientPattern"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IClientPattern.html#af67a2757eb3087a2a35fa538e702fc66">blocking</a> (const bool blocking)=0</td></tr>
<tr class="memdesc:af67a2757eb3087a2a35fa538e702fc66 inherit pub_methods_classSmart_1_1IClientPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow or abort and reject blocking calls.  <a href="#af67a2757eb3087a2a35fa538e702fc66">More...</a><br /></td></tr>
<tr class="separator:af67a2757eb3087a2a35fa538e702fc66 inherit pub_methods_classSmart_1_1IClientPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSmart_1_1ICommunicationPattern"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSmart_1_1ICommunicationPattern')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSmart_1_1ICommunicationPattern.html">Smart::ICommunicationPattern</a></td></tr>
<tr class="memitem:a541cecc6b32852bcc6400043ebbb5e76 inherit pub_methods_classSmart_1_1ICommunicationPattern"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1ICommunicationPattern.html#a541cecc6b32852bcc6400043ebbb5e76">ICommunicationPattern</a> (<a class="el" href="classSmart_1_1IComponent.html">IComponent</a> *component)</td></tr>
<tr class="memdesc:a541cecc6b32852bcc6400043ebbb5e76 inherit pub_methods_classSmart_1_1ICommunicationPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor initializing an <a class="el" href="classSmart_1_1IShutdownObserver.html" title="This class implements the Observer part of the Observer design pattern for implementing a uniform shu...">IShutdownObserver</a>.  <a href="#a541cecc6b32852bcc6400043ebbb5e76">More...</a><br /></td></tr>
<tr class="separator:a541cecc6b32852bcc6400043ebbb5e76 inherit pub_methods_classSmart_1_1ICommunicationPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058d86b0c5aaadd33d447edc86689cec inherit pub_methods_classSmart_1_1ICommunicationPattern"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1ICommunicationPattern.html#a058d86b0c5aaadd33d447edc86689cec">~ICommunicationPattern</a> ()</td></tr>
<tr class="memdesc:a058d86b0c5aaadd33d447edc86689cec inherit pub_methods_classSmart_1_1ICommunicationPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor.  <a href="#a058d86b0c5aaadd33d447edc86689cec">More...</a><br /></td></tr>
<tr class="separator:a058d86b0c5aaadd33d447edc86689cec inherit pub_methods_classSmart_1_1ICommunicationPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSmart_1_1IShutdownObserver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSmart_1_1IShutdownObserver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSmart_1_1IShutdownObserver.html">Smart::IShutdownObserver</a></td></tr>
<tr class="memitem:a558fe2252b23288bc39d298a9fe647b7 inherit pub_methods_classSmart_1_1IShutdownObserver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IShutdownObserver.html#a558fe2252b23288bc39d298a9fe647b7">IShutdownObserver</a> (<a class="el" href="classSmart_1_1ShutdownSubject.html">ShutdownSubject</a> *subject=0)</td></tr>
<tr class="memdesc:a558fe2252b23288bc39d298a9fe647b7 inherit pub_methods_classSmart_1_1IShutdownObserver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor.  <a href="#a558fe2252b23288bc39d298a9fe647b7">More...</a><br /></td></tr>
<tr class="separator:a558fe2252b23288bc39d298a9fe647b7 inherit pub_methods_classSmart_1_1IShutdownObserver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9874dc19aa11a4bc523693219dce58 inherit pub_methods_classSmart_1_1IShutdownObserver"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IShutdownObserver.html#a9f9874dc19aa11a4bc523693219dce58">~IShutdownObserver</a> ()</td></tr>
<tr class="memdesc:a9f9874dc19aa11a4bc523693219dce58 inherit pub_methods_classSmart_1_1IShutdownObserver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default destructor.  <a href="#a9f9874dc19aa11a4bc523693219dce58">More...</a><br /></td></tr>
<tr class="separator:a9f9874dc19aa11a4bc523693219dce58 inherit pub_methods_classSmart_1_1IShutdownObserver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSmart_1_1InputSubject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSmart_1_1InputSubject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSmart_1_1InputSubject.html">Smart::InputSubject&lt; EventInputType&lt; EventType, EventIdType &gt; &gt;</a></td></tr>
<tr class="memitem:a43ac5505e5afc7197fae79ab17aca68d inherit pub_methods_classSmart_1_1InputSubject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1InputSubject.html#a43ac5505e5afc7197fae79ab17aca68d">InputSubject</a> ()</td></tr>
<tr class="memdesc:a43ac5505e5afc7197fae79ab17aca68d inherit pub_methods_classSmart_1_1InputSubject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a43ac5505e5afc7197fae79ab17aca68d">More...</a><br /></td></tr>
<tr class="separator:a43ac5505e5afc7197fae79ab17aca68d inherit pub_methods_classSmart_1_1InputSubject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ef27208f06ee5b009a9ba20cd6c8f8 inherit pub_methods_classSmart_1_1InputSubject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1InputSubject.html#a02ef27208f06ee5b009a9ba20cd6c8f8">~InputSubject</a> ()</td></tr>
<tr class="memdesc:a02ef27208f06ee5b009a9ba20cd6c8f8 inherit pub_methods_classSmart_1_1InputSubject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#a02ef27208f06ee5b009a9ba20cd6c8f8">More...</a><br /></td></tr>
<tr class="separator:a02ef27208f06ee5b009a9ba20cd6c8f8 inherit pub_methods_classSmart_1_1InputSubject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classSmart_1_1IClientPattern"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSmart_1_1IClientPattern')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSmart_1_1IClientPattern.html">Smart::IClientPattern</a></td></tr>
<tr class="memitem:a7d180697720c5fc031c1860c988592d9 inherit pro_methods_classSmart_1_1IClientPattern"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IClientPattern.html#a7d180697720c5fc031c1860c988592d9">on_shutdown</a> ()</td></tr>
<tr class="memdesc:a7d180697720c5fc031c1860c988592d9 inherit pro_methods_classSmart_1_1IClientPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements individual shutdown strategy The default behavior for each client during component shutdown is to call <a class="el" href="classSmart_1_1IClientPattern.html#a7f945d0007606b60d1c17327cc56627e" title="Disconnect the service requestor from the service provider. ">disconnect()</a> which automatically disconnects the current client instance.  <a href="#a7d180697720c5fc031c1860c988592d9">More...</a><br /></td></tr>
<tr class="separator:a7d180697720c5fc031c1860c988592d9 inherit pro_methods_classSmart_1_1IClientPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSmart_1_1IShutdownObserver"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSmart_1_1IShutdownObserver')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSmart_1_1IShutdownObserver.html">Smart::IShutdownObserver</a></td></tr>
<tr class="memitem:a4a795a5b854315ee161cd465c6ce4a53 inherit pro_methods_classSmart_1_1IShutdownObserver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IShutdownObserver.html#a4a795a5b854315ee161cd465c6ce4a53">attach_self_to</a> (<a class="el" href="classSmart_1_1ShutdownSubject.html">ShutdownSubject</a> *subject)</td></tr>
<tr class="memdesc:a4a795a5b854315ee161cd465c6ce4a53 inherit pro_methods_classSmart_1_1IShutdownObserver"><td class="mdescLeft">&#160;</td><td class="mdescRight">call this method from within the constructor of derived classes  <a href="#a4a795a5b854315ee161cd465c6ce4a53">More...</a><br /></td></tr>
<tr class="separator:a4a795a5b854315ee161cd465c6ce4a53 inherit pro_methods_classSmart_1_1IShutdownObserver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89abec7de1f7abfac7bea5aaa70a3eb inherit pro_methods_classSmart_1_1IShutdownObserver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IShutdownObserver.html#ac89abec7de1f7abfac7bea5aaa70a3eb">detach_self_from</a> (<a class="el" href="classSmart_1_1ShutdownSubject.html">ShutdownSubject</a> *subject)</td></tr>
<tr class="memdesc:ac89abec7de1f7abfac7bea5aaa70a3eb inherit pro_methods_classSmart_1_1IShutdownObserver"><td class="mdescLeft">&#160;</td><td class="mdescRight">this method is called within the destructor  <a href="#ac89abec7de1f7abfac7bea5aaa70a3eb">More...</a><br /></td></tr>
<tr class="separator:ac89abec7de1f7abfac7bea5aaa70a3eb inherit pro_methods_classSmart_1_1IShutdownObserver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSmart_1_1InputSubject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSmart_1_1InputSubject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSmart_1_1InputSubject.html">Smart::InputSubject&lt; EventInputType&lt; EventType, EventIdType &gt; &gt;</a></td></tr>
<tr class="memitem:a32816c7332a29064b5bc1236557d4fab inherit pro_methods_classSmart_1_1InputSubject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1InputSubject.html#a32816c7332a29064b5bc1236557d4fab">attach</a> (<a class="el" href="classSmart_1_1IInputHandler.html">IInputHandler</a>&lt; <a class="el" href="structSmart_1_1EventInputType.html">EventInputType</a>&lt; EventType, EventIdType &gt; &gt; *handler, const unsigned int &amp;prescaleFactor=1)</td></tr>
<tr class="memdesc:a32816c7332a29064b5bc1236557d4fab inherit pro_methods_classSmart_1_1InputSubject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach an IInputHandler&lt;InputType&gt; instance.  <a href="#a32816c7332a29064b5bc1236557d4fab">More...</a><br /></td></tr>
<tr class="separator:a32816c7332a29064b5bc1236557d4fab inherit pro_methods_classSmart_1_1InputSubject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a67690573123188aa92068c05fd872d inherit pro_methods_classSmart_1_1InputSubject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1InputSubject.html#a6a67690573123188aa92068c05fd872d">detach</a> (<a class="el" href="classSmart_1_1IInputHandler.html">IInputHandler</a>&lt; <a class="el" href="structSmart_1_1EventInputType.html">EventInputType</a>&lt; EventType, EventIdType &gt; &gt; *handler)</td></tr>
<tr class="memdesc:a6a67690573123188aa92068c05fd872d inherit pro_methods_classSmart_1_1InputSubject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach an IInputHandler&lt;InputType&gt; instance.  <a href="#a6a67690573123188aa92068c05fd872d">More...</a><br /></td></tr>
<tr class="separator:a6a67690573123188aa92068c05fd872d inherit pro_methods_classSmart_1_1InputSubject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d89803983ef7bd15c95f6cc66d3aa0b inherit pro_methods_classSmart_1_1InputSubject"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1InputSubject.html#a5d89803983ef7bd15c95f6cc66d3aa0b">notify_input</a> (const <a class="el" href="structSmart_1_1EventInputType.html">EventInputType</a>&lt; EventType, EventIdType &gt; &amp;input)</td></tr>
<tr class="memdesc:a5d89803983ef7bd15c95f6cc66d3aa0b inherit pro_methods_classSmart_1_1InputSubject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies all attached IInputHandler instances about incoming data.  <a href="#a5d89803983ef7bd15c95f6cc66d3aa0b">More...</a><br /></td></tr>
<tr class="separator:a5d89803983ef7bd15c95f6cc66d3aa0b inherit pro_methods_classSmart_1_1InputSubject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classSmart_1_1IClientPattern"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classSmart_1_1IClientPattern')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classSmart_1_1IClientPattern.html">Smart::IClientPattern</a></td></tr>
<tr class="memitem:a22287e8083c537aee1fd482fdedfbbe3 inherit pro_attribs_classSmart_1_1IClientPattern"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IClientPattern.html#a22287e8083c537aee1fd482fdedfbbe3">connectionServerName</a></td></tr>
<tr class="memdesc:a22287e8083c537aee1fd482fdedfbbe3 inherit pro_attribs_classSmart_1_1IClientPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">the server-name used for the last connection (can be used in derived classes)  <a href="#a22287e8083c537aee1fd482fdedfbbe3">More...</a><br /></td></tr>
<tr class="separator:a22287e8083c537aee1fd482fdedfbbe3 inherit pro_attribs_classSmart_1_1IClientPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ea120e9bcb59cae6e9de0052c8dbf8 inherit pro_attribs_classSmart_1_1IClientPattern"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IClientPattern.html#ac7ea120e9bcb59cae6e9de0052c8dbf8">connectionServiceName</a></td></tr>
<tr class="memdesc:ac7ea120e9bcb59cae6e9de0052c8dbf8 inherit pro_attribs_classSmart_1_1IClientPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">the service-name used for the last connection (can be used in derived classes)  <a href="#ac7ea120e9bcb59cae6e9de0052c8dbf8">More...</a><br /></td></tr>
<tr class="separator:ac7ea120e9bcb59cae6e9de0052c8dbf8 inherit pro_attribs_classSmart_1_1IClientPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7d0a7ba27842c36f67adf220a3f625 inherit pro_attribs_classSmart_1_1IClientPattern"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1IClientPattern.html#aac7d0a7ba27842c36f67adf220a3f625">is_blocking</a></td></tr>
<tr class="memdesc:aac7d0a7ba27842c36f67adf220a3f625 inherit pro_attribs_classSmart_1_1IClientPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">the flag indicating the current blocking state of this client (can be used in derived classes)  <a href="#aac7d0a7ba27842c36f67adf220a3f625">More...</a><br /></td></tr>
<tr class="separator:aac7d0a7ba27842c36f67adf220a3f625 inherit pro_attribs_classSmart_1_1IClientPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classSmart_1_1ICommunicationPattern"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classSmart_1_1ICommunicationPattern')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classSmart_1_1ICommunicationPattern.html">Smart::ICommunicationPattern</a></td></tr>
<tr class="memitem:abef72528505882229d4b52a9220bb011 inherit pro_attribs_classSmart_1_1ICommunicationPattern"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmart_1_1IComponent.html">IComponent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSmart_1_1ICommunicationPattern.html#abef72528505882229d4b52a9220bb011">icomponent</a></td></tr>
<tr class="memdesc:abef72528505882229d4b52a9220bb011 inherit pro_attribs_classSmart_1_1ICommunicationPattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">the internal pointer to the component (can be accessed in derived classes)  <a href="#abef72528505882229d4b52a9220bb011">More...</a><br /></td></tr>
<tr class="separator:abef72528505882229d4b52a9220bb011 inherit pro_attribs_classSmart_1_1ICommunicationPattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ActivationType, class EventType, class EventIdType&gt;<br />
class Smart::IEventClientPattern&lt; ActivationType, EventType, EventIdType &gt;</h3>

<p>Handles the event service on client side. </p>
<p>Template parameters:</p><ul>
<li><b>P</b>: Activation parameter class (Communication Object) contains individual parameters of the event activation.</li>
<li><b>E</b>: Event answer class (Communication Object) is returned when an event fires and can contain further details why and under which circumstances an event fired.</li>
</ul>
<p>Demonstrated in <a href="/drupal/?q=node/51#fifth-example">fifth example</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa31275b23b784378e87304f90c2f6557"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ActivationType , class EventType , class EventIdType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmart_1_1IEventClientPattern.html">Smart::IEventClientPattern</a>&lt; ActivationType, EventType, EventIdType &gt;::<a class="el" href="classSmart_1_1IEventClientPattern.html">IEventClientPattern</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmart_1_1IComponent.html">IComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor (not wired with a service provider). </p>
<p><a class="el" href="classSmart_1_1IClientPattern.html#a808efd9034aa40430d793de89afc0e76" title="Connect this service requestor to the denoted service provider. ">connect()</a> / <a class="el" href="classSmart_1_1IClientPattern.html#a7f945d0007606b60d1c17327cc56627e" title="Disconnect the service requestor from the service provider. ">disconnect()</a> can always be used to change the status of the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>the management class of the component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc246ea05d3c8621d575e7c2e4fcb888"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ActivationType , class EventType , class EventIdType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmart_1_1IEventClientPattern.html">Smart::IEventClientPattern</a>&lt; ActivationType, EventType, EventIdType &gt;::<a class="el" href="classSmart_1_1IEventClientPattern.html">IEventClientPattern</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSmart_1_1IComponent.html">IComponent</a> *&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connection Constructor (implicitly wiring with specified service provider). </p>
<p>Connects to the denoted service and blocks until the connection has been established. Blocks infinitely if denoted service becomes unavailable since constructor performs retries. Blocking is useful to simplify startup of components which have mutual dependencies. <a class="el" href="classSmart_1_1IClientPattern.html#a808efd9034aa40430d793de89afc0e76" title="Connect this service requestor to the denoted service provider. ">connect()</a> / <a class="el" href="classSmart_1_1IClientPattern.html#a7f945d0007606b60d1c17327cc56627e" title="Disconnect the service requestor from the service provider. ">disconnect()</a> can always be used to change the status of the instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>the management class of the component </td></tr>
    <tr><td class="paramname">server</td><td>name of the server (i.e. the component-name to connect to) </td></tr>
    <tr><td class="paramname">service</td><td>name of the service (i.e. the port-name of the component to connect to) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad7b30e7b67ec066f79d87570446a546"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ActivationType , class EventType , class EventIdType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSmart_1_1IEventClientPattern.html">Smart::IEventClientPattern</a>&lt; ActivationType, EventType, EventIdType &gt;::~<a class="el" href="classSmart_1_1IEventClientPattern.html">IEventClientPattern</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The destructor calls <a class="el" href="classSmart_1_1IClientPattern.html#a7f945d0007606b60d1c17327cc56627e" title="Disconnect the service requestor from the service provider. ">disconnect()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a54d1a4d93b3bd3fdd35cd1170ab8af77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ActivationType , class EventType , class EventIdType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a> <a class="el" href="classSmart_1_1IEventClientPattern.html">Smart::IEventClientPattern</a>&lt; ActivationType, EventType, EventIdType &gt;::activate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSmart.html#ae5bad991dc9ede71fd0a70b79256e5b4">EventMode</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ActivationType &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventIdType &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate an event with the provided parameters in either "single" or "continuous" mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>"single" or "continuous" mode </td></tr>
    <tr><td class="paramname">parameter</td><td>activation parameter class (Communication Object) </td></tr>
    <tr><td class="paramname">id</td><td>is set to the unique id of the event activation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok, event is activated and <em>id</em> contains a valid activation identifier.</li>
<li>SMART_DISCONNECTED : activation not possible since not connected to a server. No valid activation identifier <em>id</em> returned.</li>
<li>SMART_ERROR_COMMUNICATION : communication problems, event not activated, <em>id</em> is not a valid activation identifier.</li>
<li>SMART_ERROR : something went wrong, event not activated, <em>id</em> is not a valid activation identifier. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad2531c5fe345b438cf721acf902509f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ActivationType , class EventType , class EventIdType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a> <a class="el" href="classSmart_1_1IEventClientPattern.html">Smart::IEventClientPattern</a>&lt; ActivationType, EventType, EventIdType &gt;::deactivate </td>
          <td>(</td>
          <td class="paramtype">const EventIdType &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deactivate the event with the specified identifier. </p>
<p>An event must always be deactivated, even if it has already fired in single mode. This is just necessary for cleanup procedures and provides a uniform user API independently of the event mode. Calling <a class="el" href="classSmart_1_1IEventClientPattern.html#ad2531c5fe345b438cf721acf902509f2" title="Deactivate the event with the specified identifier. ">deactivate()</a> while there are blocking calls aborts them with the appropriate status code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of event to be disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>SMART_OK : everything is ok and event is deactivated</li>
<li>SMART_WRONGID : there is no active event available with this id</li>
<li>SMART_ERROR_COMMUNICATION : communication problems, event not deactivated</li>
<li>SMART_ERROR : something went wrong, event not deactivated</li>
</ul>
</dd></dl>
<p>(Hint: can not return SMART_DISCONNECTED since then each event is for sure also deactivated resulting in SMART_WRONGID) </p>

</div>
</div>
<a class="anchor" id="a472aa91ad4afd8e5d17ba6007e96e13f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ActivationType , class EventType , class EventIdType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a> <a class="el" href="classSmart_1_1IEventClientPattern.html">Smart::IEventClientPattern</a>&lt; ActivationType, EventType, EventIdType &gt;::getEvent </td>
          <td>(</td>
          <td class="paramtype">const EventIdType &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventType &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::steady_clock::duration &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::steady_clock::duration::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking call which waits for the event to fire and then consumes the event. </p>
<p>This method consumes an event. Returns immediately if an unconsumed event is available. Blocks otherwise till event becomes available. If method is called concurrently from several threads with the same <em>id</em> and method is blocking, then every call returns with the same <em>event</em> once the event fired. If there is however already an unconsumed event available, then only one out of the concurrent calls consumes the event and the other calls return with appropriate status codes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of the event activation </td></tr>
    <tr><td class="paramname">event</td><td>is set to the returned event if fired (Communication Object) </td></tr>
    <tr><td class="paramname">timeout</td><td>is the timeout time to block the method maximally (default value zero block infinitelly)</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><b>single mode</b>: </li>
</ul>
<p>Since an event in single mode fires only once, return immediately if the event is already consumed. Also return immediately with an available and unconsumed event and consume it. Otherwise wait until the event fires. </p>
<p><b>Returns status code</b>: </p>
<ul>
<li>SMART_OK : event fired and event is consumed and returned.</li>
<li>SMART_PASSIVE : event fired and got consumed already. Returns immediately without valid event since it can not fire again in single mode.</li>
<li>SMART_CANCELLED : waiting for the event to fire has been aborted or blocking is not not allowed anymore. Therefore no valid <em>event</em> is returned.</li>
<li>SMART_DISCONNECTED : client is disconnected or got disconnected while waiting and therefore no valid <em>event</em> is returned and the activation identifier <em>id</em> is also not valid any longer due to automatic deactivation.</li>
<li>SMART_NOTACTIVATED : got deactivated while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em> and therefore <em>event</em> not valid. </li>
</ul>
<ul>
<li><b>continuous mode</b>: </li>
</ul>
<p>Returns immediately if an unconsumed event is available. Returns the newest unconsumed event since activation. Otherwise waits until the event fires again. </p>
<p><b>Returns status code</b>: </p>
<ul>
<li>SMART_OK : unconsumed event is available and event is consumed and returned. Due to the overwriting behavior, only the latest event is available.</li>
<li>SMART_CANCELLED : blocking is not allowed anymore therefore blocking call has been aborted and <em>event</em> is not valid.</li>
<li>SMART_DISCONNECTED : got disconnected while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer due to automatic deactivation.</li>
<li>SMART_NOTACTIVATED : got deactivated while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em> and therefore <em>event</em> not valid. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0912acfa105b45df68c8ee8c001c5f6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ActivationType , class EventType , class EventIdType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a> <a class="el" href="classSmart_1_1IEventClientPattern.html">Smart::IEventClientPattern</a>&lt; ActivationType, EventType, EventIdType &gt;::getNextEvent </td>
          <td>(</td>
          <td class="paramtype">const EventIdType &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventType &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::steady_clock::duration &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::steady_clock::duration::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking call which waits for the next event. </p>
<p>This methods waits for the <em>next</em> arriving event to make sure that only events arriving after entering the method are considered. Method consumes event. An old event that has been fired is ignored (in contrary to <a class="el" href="classSmart_1_1IEventClientPattern.html#a472aa91ad4afd8e5d17ba6007e96e13f" title="Blocking call which waits for the event to fire and then consumes the event. ">getEvent()</a>). If method is called concurrently from several threads with the same <em>id</em>, then every call returns with the same <em>event</em> once the event fired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of the event activation </td></tr>
    <tr><td class="paramname">event</td><td>is set to the returned event if fired (Communication Object) </td></tr>
    <tr><td class="paramname">timeout</td><td>is the timeout time to block the method maximally (default value zero block infinitelly)</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><b>single mode</b>: </li>
</ul>
<p>In single mode one misses the event if it fired before entering this member function. </p>
<p><b>Returns status code</b>: </p>
<ul>
<li>SMART_OK : event fired while waiting for the event and event is consumed and returned</li>
<li>SMART_PASSIVE : event already fired between activation and calling this member function and is therefore missed or event has already been consumed and can not fire again in single mode. Does not block indefinitely and returns no valid <em>event</em>.</li>
<li>SMART_CANCELLED : event not yet fired and waiting for the event has been aborted or blocking is not allowed anymore. No valid <em>event</em> is returned.</li>
<li>SMART_DISCONNECTED : got disconnected while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer due to automatic deactivation.</li>
<li>SMART_NOTACTIVATED : got deactivated while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em> and therefore <em>event</em> not valid. </li>
</ul>
<ul>
<li><b>continuous mode</b>: </li>
</ul>
<p>Makes sure that only events fired after entering this member function are considered. </p>
<p><b>Returns status code</b>: </p>
<ul>
<li>SMART_OK : event fired while waiting for the event and event is consumed and returned</li>
<li>SMART_CANCELLED : waiting for the next event has been aborted or blocking is not allowed anymore. No valid <em>event</em> is returned.</li>
<li>SMART_DISCONNECTED : got disconnected while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer due to automatic deactivation.</li>
<li>SMART_NOTACTIVATED : got deactivated while waiting and therefore <em>event</em> not valid and also <em>id</em> not valid any longer.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em> and therefore <em>event</em> not valid. </li>
</ul>

</div>
</div>
<a class="anchor" id="afe6f5f3a58ca6cde39da1bb35eef059f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ActivationType , class EventType , class EventIdType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceSmart.html#a0c5dfa0d01eb43e3a13e1b67c206f15b">StatusCode</a> <a class="el" href="classSmart_1_1IEventClientPattern.html">Smart::IEventClientPattern</a>&lt; ActivationType, EventType, EventIdType &gt;::tryEvent </td>
          <td>(</td>
          <td class="paramtype">const EventIdType &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether event has already fired and return immediately with status information. </p>
<p>This method does not consume an available event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>of the event activation to be checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status code<ul>
<li>single mode:<ul>
<li>SMART_OK : event fired already, is still available and can be consumed by calling <a class="el" href="classSmart_1_1IEventClientPattern.html#a472aa91ad4afd8e5d17ba6007e96e13f" title="Blocking call which waits for the event to fire and then consumes the event. ">getEvent()</a>,</li>
<li>SMART_ACTIVE : event has not yet fired</li>
<li>SMART_PASSIVE : event fired already and is already consumed.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em></li>
</ul>
</li>
<li>continuous mode:<ul>
<li>SMART_OK : unconsumed event is available. Since events are overwritten this means that at least one new event has been received since the last event consumption.</li>
<li>SMART_ACTIVE : currently there is no unconsumed event available.</li>
<li>SMART_WRONGID : there is no activation available with this <em>id</em> </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>smartIEventClientPattern_T.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
